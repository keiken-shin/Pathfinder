{"version":3,"sources":["webpack://pathfinder/./src/components/algorithms/unweighted/get-neighbors.ts","webpack://pathfinder/./src/components/animations/node-traverse.ts","webpack://pathfinder/./src/components/animations/index.ts","webpack://pathfinder/./src/components/node.ts","webpack://pathfinder/./src/components/data.ts","webpack://pathfinder/./src/index.ts","webpack://pathfinder/./src/components/board.ts","webpack://pathfinder/./src/components/algorithms/unweighted/depth-first-search.ts","webpack://pathfinder/./src/components/animations/node-shortest-distance.ts"],"names":["nodeId","listOfNodes","grid","coordinates","split","x","parseInt","y","neighbor","potentialNeighbor","toString","status","unshift","nodesInOrder","Promise","resolve","i","length","setTimeout","id","node","document","getElementById","classList","contains","add","className","NODE_ANIMATION_TIME","Node","row","column","this","distance","previousNode","DATA","HEADER_HEIGHT","Number","querySelector","clientHeight","CONTENT_HEIGHT","height","width","isStart","isTarget","allNodes","shortestPathNodesInOrder","visualizeComponent","descriptionComponent","initialStart","Math","floor","col","initialTarget","pressedNodeStatus","mouseDown","previouslySwitchedNode","previouslyPressedNodeStatus","createGrid","toggleSwitch","eventListeners","board","tbody","createElement","currentArrayRow","currentRow","nodeStatus","newNode","push","tableCell","append","addEventListener","dataVisualize","getAttribute","drawShortestPath","e","dataId","target","dataset","textContent","setAttribute","innerHTML","startNode","targetNode","stack","exploredNode","currentNode","pop","forEach","traverse","console","log","nodesInShortestOrder","Object","entries","map","key","value","currentElement","changeNormalNode","changeSpecialNode","includes","previousElement","documentElement","scrollHeight","clientWidth","initialize"],"mappings":"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","file":"main.js","sourcesContent":["import { CustomNode, ListOfCustomNode } from \"../../node\";\r\n\r\nconst getNeighbors = (\r\n    nodeId: string,\r\n    listOfNodes: ListOfCustomNode,\r\n    grid: CustomNode[][]\r\n) => {\r\n    const coordinates: string[] = nodeId.split(\"-\");\r\n    const x: number = parseInt(coordinates[0]);\r\n    const y: number = parseInt(coordinates[1]);\r\n\r\n    const neighbor = [];\r\n    let potentialNeighbor: string;\r\n\r\n    // if there exist a row above current row and current col idx in that row\r\n    if (grid[x - 1] && grid[x - 1][y]) {\r\n        potentialNeighbor = `${(x - 1).toString()}-${y.toString()}`; // make that coords potential neighbor\r\n        if (listOfNodes[potentialNeighbor].status !== \"wall\") {\r\n            neighbor.unshift(potentialNeighbor); // Add potentialNeighbor at the beginning of neighbor array if node is not wall\r\n        }\r\n    }\r\n\r\n    // if there exist next column in current row\r\n    if (grid[x][y + 1]) {\r\n        potentialNeighbor = `${x.toString()}-${(y + 1).toString()}`; // make that coords potential neighbor\r\n        if (listOfNodes[potentialNeighbor].status !== \"wall\") {\r\n            neighbor.unshift(potentialNeighbor);\r\n        }\r\n    }\r\n\r\n    if (grid[x + 1] && grid[x + 1][y]) {\r\n        potentialNeighbor = `${(x + 1).toString()}-${y.toString()}`; // make that coords potential neighbor\r\n        if (listOfNodes[potentialNeighbor].status !== \"wall\") {\r\n            neighbor.unshift(potentialNeighbor);\r\n        }\r\n    }\r\n\r\n    if (grid[x][y - 1]) {\r\n        potentialNeighbor = `${x.toString()}-${(y - 1).toString()}`; // make that coords potential neighbor\r\n        if (listOfNodes[potentialNeighbor].status !== \"wall\") {\r\n            neighbor.unshift(potentialNeighbor);\r\n        }\r\n    }\r\n\r\n    return neighbor;\r\n};\r\n\r\nexport default getNeighbors;\r\n","import { CustomNode } from \"../node\";\r\nimport { NODE_ANIMATION_TIME } from \"./index\";\r\n\r\nconst nodeTraverse = async(nodesInOrder: CustomNode[]) => {\r\n    return new Promise((resolve) => {\r\n        for (let i: number= 0; i < nodesInOrder.length; i++){\r\n            setTimeout(() => {\r\n                const id: string= nodesInOrder[i].id;\r\n                const node: Element= document.getElementById(id)!;\r\n    \r\n                node.classList.contains(\"isStart\") || node.classList.contains(\"isTarget\") \r\n                ? node.classList.add(\"visited\")\r\n                : node.className = \"visited\";\r\n    \r\n                if(i === nodesInOrder.length - 1) resolve(true);\r\n            }, NODE_ANIMATION_TIME * i);\r\n\r\n        }\r\n    })\r\n}\r\n\r\nexport default nodeTraverse;","export const NODE_ANIMATION_TIME = 12;\r\n\r\nexport { default as nodeTraverse } from './node-traverse';\r\nexport { default as shortestDistance } from './node-shortest-distance';\r\n","interface CustomNode {\r\n  id: string,\r\n  row: number,\r\n  column: number,\r\n  status: string,\r\n  distance: number,\r\n  previousNode: CustomNode | null\r\n}\r\n\r\ninterface ListOfCustomNode{\r\n  [propNames: string]: CustomNode\r\n}\r\n\r\nclass Node {\r\n  id: string;\r\n  distance: number;\r\n  previousNode: CustomNode | null;\r\n\r\n  constructor(\r\n    public row: number,\r\n    public column: number,\r\n    public status: string\r\n  ){\r\n    this.id = `${row}-${column}`;\r\n    this.distance = 0;\r\n    this.previousNode = null;\r\n  }\r\n}\r\n\r\nexport {\r\n  Node,\r\n  CustomNode,\r\n  ListOfCustomNode\r\n}","interface CustomData {\r\n    [prop: string]: string\r\n}\r\n\r\nexport const DATA: CustomData = {\r\n    \"DFS\": \"Depth-first Search is <strong>&nbsp; unweighted &nbsp;</strong> and <strong>&nbsp; does not guarantee &nbsp;</strong> the shortest path!\",\r\n    \"BFS\": \"Breath-first Search is <strong>&nbsp; unweighted &nbsp;</strong> and <strong>&nbsp; does not guarantee &nbsp;</strong> the shortest path!\"\r\n}\r\n  ","import Board from './components/board';\r\nimport \"./style.scss\";\r\n\r\n// Get Height of other elements in body\r\nconst HEADER_HEIGHT: number = Number(document.querySelector(\".header\")?.clientHeight);\r\nconst CONTENT_HEIGHT: number = Number(document.querySelector(\".description\")?.clientHeight) + Number(document.querySelector(\".intro\")?.clientHeight);\r\n\r\n// Obtain height and width of board\r\nconst BOARD_HEIGHT: number = Math.floor((Number(document.documentElement.scrollHeight) - HEADER_HEIGHT - CONTENT_HEIGHT) / 28);\r\nconst BOARD_WIDTH: number = Math.floor(Number(document.documentElement.clientWidth) / 25);\r\n\r\nconst BOARD = new Board(BOARD_HEIGHT, BOARD_WIDTH);\r\nBOARD.initialize();","import depthFirstSearch from \"./algorithms/unweighted/depth-first-search\";\r\nimport { shortestDistance } from \"./animations/index\";\r\nimport nodeTraverse from \"./animations/node-traverse\";\r\nimport { CustomNode, Node, ListOfCustomNode } from \"./node\";\r\nimport { DATA } from \"./data\";\r\n\r\nclass Board {\r\n    isStart: string; // Starting Point\r\n    isTarget: string; // Target Point\r\n    allNodes: ListOfCustomNode; // Contains instance of all the nodes present in board with \"node_id\" as \"key\" and \"Node itself\" as \"value\"\r\n    grid: CustomNode[][]; // Storing all table rows \"Array<Array<CustomNode>>\"\r\n    nodesInOrder: CustomNode[]; // Stores node in an order in which it is traversed\r\n    shortestPathNodesInOrder: CustomNode[]; // Contains shortest path nodes\r\n\r\n    visualizeComponent: HTMLElement; // Getting Visualize Button\r\n    descriptionComponent: HTMLElement; // Getting Description Component\r\n\r\n    initialStart: { row: number; col: number }; // Initializing start node\r\n    initialTarget: { row: number; col: number }; // Initializing target node\r\n\r\n    pressedNodeStatus: string; // On mouse event - stores pressed node status\r\n    mouseDown: boolean; // To check whether the mouse is pressed or not\r\n    previouslySwitchedNode: CustomNode | null; // Tracking previously switched node\r\n    previouslyPressedNodeStatus: string; // Tracking previously pressed node status\r\n\r\n    constructor(public height: number, public width: number) {\r\n        this.isStart = \"\";\r\n        this.isTarget = \"\";\r\n        this.allNodes = {};\r\n        this.grid = [];\r\n        this.nodesInOrder = [];\r\n        this.shortestPathNodesInOrder = [];\r\n\r\n        this.visualizeComponent = <HTMLElement>(\r\n            document.querySelector(\"#visualize\")!\r\n        );\r\n        this.descriptionComponent = <HTMLElement>(\r\n            document.querySelector(\".description\")!\r\n        );\r\n\r\n        this.initialStart = {\r\n            row: Math.floor(this.height / 2),\r\n            col: Math.floor(this.width / 4),\r\n        };\r\n        this.initialTarget = {\r\n            row: Math.floor(this.height / 2),\r\n            col: Math.floor((3 * this.width) / 4),\r\n        };\r\n\r\n        this.pressedNodeStatus = \"\";\r\n        this.mouseDown = false;\r\n        this.previouslySwitchedNode = null;\r\n        this.previouslyPressedNodeStatus = \"\";\r\n    }\r\n\r\n    initialize() {\r\n        this.createGrid();\r\n        this.toggleSwitch();\r\n        this.eventListeners();\r\n    }\r\n\r\n    createGrid() {\r\n        const board: Element = document.querySelector(\"#board\")!; // Select Board Elements (! -> mandatory)\r\n        const tbody: Element = document.createElement(\"tbody\");\r\n\r\n        for (let row: number = 0; row < this.height; row++) {\r\n            const currentArrayRow: Node[] = [];\r\n\r\n            // Create table row element\r\n            const currentRow: HTMLTableRowElement =\r\n                document.createElement(\"tr\");\r\n            currentRow.id = `row ${row}`;\r\n\r\n            for (let col: number = 0; col < this.width; col++) {\r\n                const nodeId: string = `${row}-${col}`;\r\n\r\n                let nodeStatus: string, newNode: CustomNode;\r\n\r\n                // Calculating start and target position\r\n                if (\r\n                    row === this.initialStart.row &&\r\n                    col === this.initialStart.col\r\n                ) {\r\n                    nodeStatus = \"isStart\"; // marking current node as start node\r\n                    this.isStart = nodeId; // storing current node in isStart\r\n                } else if (\r\n                    row === this.initialTarget.row &&\r\n                    col === this.initialTarget.col\r\n                ) {\r\n                    nodeStatus = \"isTarget\"; // marking current node as target node\r\n                    this.isTarget = nodeId; // storing current node in isTarget\r\n                } else {\r\n                    nodeStatus = \"unvisited\"; // marking rest as unvisited\r\n                }\r\n\r\n                newNode = new Node(row, col, nodeStatus); // Creating instance of node\r\n                currentArrayRow.push(newNode); // Pushing new instance in row array\r\n                this.allNodes[nodeId] = newNode; // Storing it inside allNodes\r\n\r\n                // Creating board cell\r\n                const tableCell: HTMLTableDataCellElement =\r\n                    document.createElement(\"td\");\r\n                tableCell.id = nodeId;\r\n                tableCell.classList.add(nodeStatus);\r\n\r\n                currentRow.append(tableCell);\r\n            }\r\n            this.grid.push(currentArrayRow);\r\n            tbody.append(currentRow);\r\n            board.append(tbody);\r\n        }\r\n\r\n        // Visualize\r\n        this.visualizeComponent.addEventListener(\"click\", () => {\r\n            const dataVisualize: string =\r\n                this.visualizeComponent.getAttribute(\"data-visualize\")!;\r\n            if (dataVisualize !== \"\") {\r\n                this.drawShortestPath(dataVisualize);\r\n            }\r\n        });\r\n    }\r\n\r\n    toggleSwitch() {\r\n        const algorithmsList = document.querySelector(\"#algorithms-list\")!;\r\n\r\n        algorithmsList.addEventListener(\"mousedown\", (e) => {\r\n            const el = e.target as HTMLElement;\r\n            const dataId = el.dataset.id;\r\n\r\n            if (dataId) {\r\n                this.visualizeComponent.textContent = `Visualize ${dataId}`;\r\n                this.visualizeComponent.setAttribute(\r\n                    \"data-visualize\",\r\n                    `${dataId}`\r\n                );\r\n                this.descriptionComponent.innerHTML = DATA[dataId];\r\n            }\r\n        });\r\n    }\r\n\r\n    async drawShortestPath(dataVisualize: string) {\r\n        if (dataVisualize === \"DFS\") {\r\n            depthFirstSearch(\r\n                this.allNodes,\r\n                this.isStart,\r\n                this.isTarget,\r\n                this.grid,\r\n                this.nodesInOrder\r\n            );\r\n            const traverse = await nodeTraverse(this.nodesInOrder);\r\n            console.log(this.nodesInOrder);\r\n            traverse &&\r\n                shortestDistance(\r\n                    this.shortestPathNodesInOrder,\r\n                    this.isStart,\r\n                    this.isTarget,\r\n                    this.allNodes\r\n                );\r\n        }\r\n    }\r\n\r\n    eventListeners() {\r\n        Object.entries(this.allNodes).map((node) => {\r\n            const [key, value] = node; // \"key\" represents ID & \"value\" represents NODE\r\n            const currentElement: HTMLElement = document.getElementById(key)!; // Not using query-selector as it does not support id starting with digit\r\n\r\n            // On mouse press event\r\n            currentElement.addEventListener(\"mousedown\", (e) => {\r\n                const target: HTMLElement = <HTMLElement>e.target;\r\n\r\n                this.mouseDown = true;\r\n\r\n                if (value.status === \"isStart\" || value.status === \"isTarget\") {\r\n                    this.pressedNodeStatus = value.status;\r\n                } else {\r\n                    this.changeNormalNode(target, value);\r\n                    console.log(node);\r\n                }\r\n            });\r\n\r\n            // On mouse release event\r\n            currentElement.addEventListener(\"mouseup\", () => {\r\n                this.mouseDown = false;\r\n\r\n                if (this.pressedNodeStatus === \"isStart\") {\r\n                    this.isStart = key;\r\n                } else if (this.pressedNodeStatus === \"isTarget\") {\r\n                    this.isTarget = key;\r\n                }\r\n\r\n                this.pressedNodeStatus = \"normal\";\r\n            });\r\n\r\n            // On mouse hovering event\r\n            currentElement.addEventListener(\"mouseenter\", (e) => {\r\n                if (this.mouseDown) {\r\n                    const target: HTMLElement = <HTMLElement>e.target;\r\n                    if (this.mouseDown && this.pressedNodeStatus !== \"normal\") {\r\n                        this.changeSpecialNode(target, value);\r\n                        if (this.pressedNodeStatus === \"isStart\") {\r\n                            this.isStart = key;\r\n                        } else if (this.pressedNodeStatus === \"isTarget\") {\r\n                            this.isTarget = key;\r\n                        }\r\n                    } else {\r\n                        this.changeNormalNode(target, value);\r\n                    }\r\n                }\r\n            });\r\n\r\n            // On mouse leave event\r\n            currentElement.addEventListener(\"mouseleave\", (e) => {\r\n                const target: HTMLElement = <HTMLElement>e.target;\r\n\r\n                if (this.mouseDown && this.pressedNodeStatus !== \"normal\") {\r\n                    this.changeSpecialNode(target, value);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    // Changing normal node role from unvisited to wall or v.v.\r\n    changeNormalNode(target: HTMLElement, node: CustomNode) {\r\n        const relevantStatus = [\"isStart\", \"isTarget\"];\r\n\r\n        if (!relevantStatus.includes(node.status)) {\r\n            target.className =\r\n                node.status === \"unvisited\" ? \"wall\" : \"unvisited\";\r\n            node.status =\r\n                target.className === \"unvisited\" ? \"unvisited\" : \"wall\";\r\n        }\r\n    }\r\n\r\n    // Changing special (i.e., start, target) node position\r\n    changeSpecialNode(target: HTMLElement, node: CustomNode) {\r\n        let previousElement: HTMLElement | null = null;\r\n\r\n        // If there exist previous switched node get that element\r\n        this.previouslySwitchedNode !== null &&\r\n            (previousElement = document.getElementById(\r\n                this.previouslySwitchedNode.id\r\n            ));\r\n\r\n        if (node.status !== \"isStart\" && node.status !== \"isTarget\") {\r\n            if (this.previouslySwitchedNode) {\r\n                this.previouslySwitchedNode.status =\r\n                    this.previouslyPressedNodeStatus;\r\n                previousElement!.className = this.previouslyPressedNodeStatus;\r\n\r\n                this.previouslySwitchedNode = null;\r\n\r\n                this.previouslyPressedNodeStatus = node.status;\r\n                target.className = this.pressedNodeStatus;\r\n                node.status = this.pressedNodeStatus;\r\n            }\r\n        } else if (node.status !== this.pressedNodeStatus) {\r\n            if (this.previouslySwitchedNode) {\r\n                this.previouslySwitchedNode.status = this.pressedNodeStatus;\r\n                previousElement!.className = this.pressedNodeStatus;\r\n            }\r\n        } else if (node.status === this.pressedNodeStatus) {\r\n            this.previouslySwitchedNode = node;\r\n            target.className = this.previouslyPressedNodeStatus;\r\n            node.status = this.previouslyPressedNodeStatus;\r\n        }\r\n    }\r\n}\r\n\r\nexport default Board;\r\n","import { CustomNode, ListOfCustomNode } from \"../../node\";\r\nimport getNeighbors from \"./get-neighbors\";\r\n\r\nconst depthFirstSearch = (\r\n    listOfNodes: ListOfCustomNode, \r\n    startNode: string, \r\n    targetNode: string, \r\n    grid: CustomNode[][],\r\n    nodesInOrder: CustomNode[]\r\n): boolean => {\r\n\r\n    if (startNode === \"\" || targetNode === \"\" || startNode === targetNode) return false;\r\n\r\n    let stack: CustomNode[] = [listOfNodes[startNode]]\r\n    const exploredNode: {\r\n        [propNames: string] : boolean\r\n    } = {startNode: true}\r\n\r\n    while (stack.length){\r\n        let currentNode: CustomNode = stack.pop()!;\r\n        exploredNode[currentNode.id] = true;\r\n        nodesInOrder.push(currentNode);\r\n        currentNode.status = \"visited\";\r\n\r\n        if (currentNode.id === targetNode) return true;\r\n\r\n        let currentNeighbors = getNeighbors(currentNode.id, listOfNodes, grid);\r\n        currentNeighbors.forEach(neighbor => {\r\n            if (!exploredNode[neighbor]){\r\n                listOfNodes[neighbor].previousNode = currentNode;\r\n                stack.push(listOfNodes[neighbor]);\r\n            }\r\n        })\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport default depthFirstSearch;","import { CustomNode, ListOfCustomNode } from \"../node\";\r\nimport { NODE_ANIMATION_TIME } from \"./index\";\r\n\r\nconst shortestDistance = (nodesInShortestOrder: CustomNode[], isStart: string, isTarget: string, allNodes: ListOfCustomNode) => {\r\n    \r\n    let currentNode: CustomNode | null= allNodes[isTarget];\r\n\r\n    /* \r\n        Looping through while current node is not equal to start node \r\n        to get the shortest route that it has to traverse to reach its destination\r\n    */\r\n    while(currentNode !== null){\r\n        nodesInShortestOrder.unshift(currentNode);\r\n        currentNode = allNodes[currentNode.id].previousNode;\r\n    }\r\n    \r\n    // Animating nodesInShortestOrder\r\n    for (let i: number= 0; i < nodesInShortestOrder.length; i++){\r\n        setTimeout(() => {\r\n            const id: string= nodesInShortestOrder[i].id;\r\n            const node: Element= document.getElementById(id)!;\r\n\r\n            node.classList.contains(\"isStart\") || node.classList.contains(\"isTarget\") \r\n            ? node.classList.add(\"shortest-path\")\r\n            : node.className = \"shortest-path\";\r\n\r\n        }, NODE_ANIMATION_TIME * (2 * i));\r\n    }\r\n}\r\n\r\nexport default shortestDistance;"],"sourceRoot":""}