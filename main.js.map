{"version":3,"sources":["webpack://pathfinder/./src/components/algorithms/unweighted/get-neighbors.ts","webpack://pathfinder/./src/components/animations/node-traverse.ts","webpack://pathfinder/./src/components/animations/index.ts","webpack://pathfinder/./src/components/node.ts","webpack://pathfinder/./src/components/data.ts","webpack://pathfinder/./src/index.ts","webpack://pathfinder/./src/components/board.ts","webpack://pathfinder/./src/components/algorithms/unweighted/depth-first-search.ts","webpack://pathfinder/./src/components/animations/node-shortest-distance.ts"],"names":["nodeId","listOfNodes","grid","coordinates","split","x","parseInt","y","neighbor","potentialNeighbor","toString","status","unshift","nodesInOrder","Promise","resolve","i","length","setTimeout","id","node","document","getElementById","classList","contains","add","className","NODE_ANIMATION_TIME","Node","row","column","this","distance","previousNode","DATA","HEADER_HEIGHT","Number","querySelector","clientHeight","CONTENT_HEIGHT","height","width","isStart","isTarget","allNodes","shortestPathNodesInOrder","visualizeComponent","descriptionComponent","initialStart","Math","floor","col","initialTarget","pressedNodeStatus","mouseDown","previouslySwitchedNode","previouslyPressedNodeStatus","createGrid","toggleSwitch","eventListeners","board","tbody","createElement","currentArrayRow","currentRow","nodeStatus","newNode","push","tableCell","append","addEventListener","dataVisualize","getAttribute","drawShortestPath","e","dataId","target","dataset","textContent","setAttribute","innerHTML","startNode","targetNode","stack","exploredNode","currentNode","pop","forEach","traverse","console","log","nodesInShortestOrder","Object","entries","map","key","value","currentElement","changeNormalNode","changeSpecialNode","includes","previousElement","documentElement","scrollHeight","clientWidth","initialize"],"mappings":"mBAEA,MA6CA,EA7CqB,CACjBA,EACAC,EACAC,KAEA,MAAMC,EAAuBH,EAAOI,MAAM,KACpCC,EAAWC,SAASH,EAAY,IAChCI,EAAWD,SAASH,EAAY,IAEhCK,EAAW,GACjB,IAAIC,EAgCJ,OA7BIP,EAAKG,EAAE,IAAMH,EAAKG,EAAE,GAAGE,KACvBE,EAAoB,IAAIJ,EAAI,GAAGK,cAAeH,EAAEG,aACH,SAA1CT,EAAYQ,GAAmBE,QAC9BH,EAASI,QAAQH,IAKrBP,EAAKG,GAAGE,EAAI,KACZE,EAAoB,GAAGJ,EAAEK,eAAeH,EAAI,GAAGG,aACF,SAA1CT,EAAYQ,GAAmBE,QAC9BH,EAASI,QAAQH,IAIrBP,EAAKG,EAAI,IAAMH,EAAKG,EAAI,GAAGE,KAC3BE,EAAoB,IAAIJ,EAAI,GAAGK,cAAc,EAAIA,aACJ,SAA1CT,EAAYQ,GAAmBE,QAC9BH,EAASI,QAAQH,IAIrBP,EAAKG,GAAGE,EAAI,KACZE,EAAoB,GAAGJ,EAAEK,eAAeH,EAAI,GAAGG,aACF,SAA1CT,EAAYQ,GAAmBE,QAC9BH,EAASI,QAAQH,IAIlBD,GCzCX,MAkBA,EAlB2BK,IAA+B,O,OAAD,E,OAAA,E,EAAA,YACrD,OAAO,IAAIC,SAASC,IAChB,IAAK,IAAIC,EAAW,EAAGA,EAAIH,EAAaI,OAAQD,IAC5CE,YAAW,KACP,MAAMC,EAAYN,EAAaG,GAAGG,GAC5BC,EAAeC,SAASC,eAAeH,GAE7CC,EAAKG,UAAUC,SAAS,YAAcJ,EAAKG,UAAUC,SAAS,YAC5DJ,EAAKG,UAAUE,IAAI,WACnBL,EAAKM,UAAY,UAEhBV,IAAMH,EAAaI,OAAS,GAAGF,GAAQ,KAC3CY,EAAsBX,O,YAZoB,K,+QCH5CW,EAAsB,GCanC,MAAMC,EAKJ,YACSC,EACAC,EACAnB,GAFA,KAAAkB,MACA,KAAAC,SACA,KAAAnB,SAEPoB,KAAKZ,GAAK,GAAGU,KAAOC,IACpBC,KAAKC,SAAW,EAChBD,KAAKE,aAAe,MCrBjB,MAAMC,EAAmB,CAC5B,IAAO,2IACP,IAAO,6I,UCFX,MAAMC,EAAwBC,OAAwC,QAAlC,EAACf,SAASgB,cAAc,kBAAU,eAAEC,cAClEC,EAAyBH,OAA6C,QAAvC,EAACf,SAASgB,cAAc,uBAAe,eAAEC,cAAgBF,OAAuC,QAAjC,EAACf,SAASgB,cAAc,iBAAS,eAAEC,cAMzH,ICLd,MAmBI,YACWE,EACAC,GADA,KAAAD,SACA,KAAAC,QAEPV,KAAKW,QAAU,GACfX,KAAKY,SAAW,GAChBZ,KAAKa,SAAW,GAChBb,KAAK7B,KAAO,GACZ6B,KAAKlB,aAAe,GACpBkB,KAAKc,yBAA2B,GAEhCd,KAAKe,mBAAkCzB,SAASgB,cAAc,cAC9DN,KAAKgB,qBAAoC1B,SAASgB,cAAc,gBAEhEN,KAAKiB,aAAe,CAChBnB,IAAKoB,KAAKC,MAAMnB,KAAKS,OAAS,GAC9BW,IAAKF,KAAKC,MAAMnB,KAAKU,MAAQ,IAEjCV,KAAKqB,cAAgB,CACjBvB,IAAKoB,KAAKC,MAAMnB,KAAKS,OAAS,GAC9BW,IAAKF,KAAKC,MAAM,EAAInB,KAAKU,MAAQ,IAGrCV,KAAKsB,kBAAoB,GACzBtB,KAAKuB,WAAY,EACjBvB,KAAKwB,uBAAyB,KAC9BxB,KAAKyB,4BAA8B,GAGvC,aACIzB,KAAK0B,aACL1B,KAAK2B,eACL3B,KAAK4B,iBAGT,aACI,MAAMC,EAAiBvC,SAASgB,cAAc,UACxCwB,EAAiBxC,SAASyC,cAAc,SAE9C,IAAK,IAAIjC,EAAc,EAAGA,EAAME,KAAKS,OAAQX,IAAM,CAC/C,MAAMkC,EAA0B,GAG1BC,EAAkC3C,SAASyC,cAAc,MAC/DE,EAAW7C,GAAK,OAAOU,IAEvB,IAAK,IAAIsB,EAAc,EAAGA,EAAMpB,KAAKU,MAAOU,IAAM,CAC9C,MAAMnD,EAAgB,GAAG6B,KAAOsB,IAEhC,IAAIc,EACAC,EAGArC,IAAQE,KAAKiB,aAAanB,KAAOsB,IAAQpB,KAAKiB,aAAaG,KAC3Dc,EAAa,UACblC,KAAKW,QAAU1C,GACT6B,IAAQE,KAAKqB,cAAcvB,KAAOsB,IAAQpB,KAAKqB,cAAcD,KACnEc,EAAa,WACblC,KAAKY,SAAW3C,GAEhBiE,EAAa,YAGjBC,EAAU,IAAItC,EAAKC,EAAKsB,EAAKc,GAC7BF,EAAgBI,KAAKD,GACrBnC,KAAKa,SAAS5C,GAAUkE,EAGxB,MAAME,EAAqC/C,SAASyC,cAAc,MAClEM,EAAUjD,GAAKnB,EACfoE,EAAU7C,UAAUE,IAAIwC,GAExBD,EAAWK,OAAOD,GAEtBrC,KAAK7B,KAAKiE,KAAKJ,GACfF,EAAMQ,OAAOL,GACbJ,EAAMS,OAAOR,GAIjB9B,KAAKe,mBAAmBwB,iBAAiB,SAAS,KAC9C,MAAMC,EAAwBxC,KAAKe,mBAAmB0B,aAAa,kBAC9C,KAAlBD,GACCxC,KAAK0C,iBAAiBF,MAKlC,eAC2BlD,SAASgB,cAAc,oBAE/BiC,iBAAiB,aAAcI,IAC1C,MACMC,EADKD,EAAEE,OACKC,QAAQ1D,GAEtBwD,IACA5C,KAAKe,mBAAmBgC,YAAc,aAAaH,IACnD5C,KAAKe,mBAAmBiC,aAAa,iBAAkB,GAAGJ,KAC1D5C,KAAKgB,qBAAqBiC,UAAY9C,EAAKyC,OAKjD,iBAAiBJ,G,qCACnB,GAAqB,QAAlBA,EAAwB,CC9HV,EACrBtE,EACAgF,EACAC,EACAhF,EACAW,KAGA,GAAkB,KAAdoE,GAAmC,KAAfC,GAAqBD,IAAcC,EAAY,OAAO,EAE9E,IAAIC,EAAsB,CAAClF,EAAYgF,IACvC,MAAMG,EAEF,CAACH,WAAW,GAEhB,KAAOE,EAAMlE,QAAO,CAChB,IAAIoE,EAA0BF,EAAMG,MAKpC,GAJAF,EAAaC,EAAYlE,KAAM,EAC/BN,EAAasD,KAAKkB,GAClBA,EAAY1E,OAAS,UAEjB0E,EAAYlE,KAAO+D,EAAY,OAAO,EAEnB,EAAaG,EAAYlE,GAAIlB,EAAaC,GAChDqF,SAAQ/E,IAChB4E,EAAa5E,KACdP,EAAYO,GAAUyB,aAAeoD,EACrCF,EAAMhB,KAAKlE,EAAYO,UDoG3B,CAAiBuB,KAAKa,SAAUb,KAAKW,QAASX,KAAKY,SAAUZ,KAAK7B,KAAM6B,KAAKlB,cAC7E,MAAM2E,QAAiB,EAAazD,KAAKlB,cACzC4E,QAAQC,IAAI3D,KAAKlB,cACjB2E,GElIa,EAACG,EAAoCjD,EAAiBC,EAAkBC,KAE7F,IAAIyC,EAAgCzC,EAASD,GAM7C,KAAsB,OAAhB0C,GACFM,EAAqB/E,QAAQyE,GAC7BA,EAAczC,EAASyC,EAAYlE,IAAIc,aAI3C,IAAK,IAAIjB,EAAW,EAAGA,EAAI2E,EAAqB1E,OAAQD,IACpDE,YAAW,KACP,MAAMC,EAAYwE,EAAqB3E,GAAGG,GACpCC,EAAeC,SAASC,eAAeH,GAE7CC,EAAKG,UAAUC,SAAS,YAAcJ,EAAKG,UAAUC,SAAS,YAC5DJ,EAAKG,UAAUE,IAAI,iBACnBL,EAAKM,UAAY,kBAEpBC,GAAuB,EAAIX,KF2Gd,CAAiBe,KAAKc,yBAA0Bd,KAAKW,QAASX,KAAKY,SAAUZ,KAAKa,Y,+RAItG,iBACIgD,OAAOC,QAAQ9D,KAAKa,UAAUkD,KAAI1E,IAC9B,MAAO2E,EAAKC,GAAS5E,EACf6E,EAA6B5E,SAASC,eAAeyE,GAG3DE,EAAe3B,iBAAiB,aAAcI,IAC1C,MAAME,EAAmCF,EAAEE,OAE3C7C,KAAKuB,WAAY,EAEG,YAAjB0C,EAAMrF,QAAyC,aAAjBqF,EAAMrF,OACnCoB,KAAKsB,kBAAoB2C,EAAMrF,QAE/BoB,KAAKmE,iBAAiBtB,EAAQoB,GAC9BP,QAAQC,IAAItE,OAKpB6E,EAAe3B,iBAAiB,WAAW,KACvCvC,KAAKuB,WAAY,EAEa,YAA3BvB,KAAKsB,kBACJtB,KAAKW,QAAUqD,EACiB,aAA3BhE,KAAKsB,oBACVtB,KAAKY,SAAWoD,GAGpBhE,KAAKsB,kBAAoB,YAI7B4C,EAAe3B,iBAAiB,cAAeI,IAC3C,GAAG3C,KAAKuB,UAAU,CACd,MAAMsB,EAAmCF,EAAEE,OACxC7C,KAAKuB,WAAwC,WAA3BvB,KAAKsB,mBACtBtB,KAAKoE,kBAAkBvB,EAAQoB,GACD,YAA3BjE,KAAKsB,kBACJtB,KAAKW,QAAUqD,EACiB,aAA3BhE,KAAKsB,oBACVtB,KAAKY,SAAWoD,IAGpBhE,KAAKmE,iBAAiBtB,EAAQoB,OAM1CC,EAAe3B,iBAAiB,cAAeI,IAC3C,MAAME,EAAmCF,EAAEE,OAExC7C,KAAKuB,WAAwC,WAA3BvB,KAAKsB,mBACtBtB,KAAKoE,kBAAkBvB,EAAQoB,SAO/C,iBAAiBpB,EAAqBxD,GACX,CAAC,UAAW,YAEhBgF,SAAShF,EAAKT,UAC7BiE,EAAOlD,UAA4B,cAAhBN,EAAKT,OAAyB,OAAS,YAC1DS,EAAKT,OAA8B,cAArBiE,EAAOlD,UAA4B,YAAc,QAKvE,kBAAkBkD,EAAqBxD,GACnC,IAAIiF,EAAsC,KAGV,OAAhCtE,KAAKwB,yBACD8C,EAAkBhF,SAASC,eAAeS,KAAKwB,uBAAuBpC,KAEvD,YAAhBC,EAAKT,QAAwC,aAAhBS,EAAKT,OAC9BoB,KAAKwB,yBACJxB,KAAKwB,uBAAuB5C,OAASoB,KAAKyB,4BAC1C6C,EAAiB3E,UAAYK,KAAKyB,4BAElCzB,KAAKwB,uBAAyB,KAE9BxB,KAAKyB,4BAA8BpC,EAAKT,OACxCiE,EAAOlD,UAAYK,KAAKsB,kBACxBjC,EAAKT,OAASoB,KAAKsB,mBAElBjC,EAAKT,SAAWoB,KAAKsB,kBACvBtB,KAAKwB,yBACJxB,KAAKwB,uBAAuB5C,OAASoB,KAAKsB,kBAC1CgD,EAAiB3E,UAAYK,KAAKsB,mBAEjCjC,EAAKT,SAAWoB,KAAKsB,oBAC1BtB,KAAKwB,uBAAyBnC,EAC9BwD,EAAOlD,UAAYK,KAAKyB,4BACxBpC,EAAKT,OAASoB,KAAKyB,+BDlOFP,KAAKC,OAAOd,OAAOf,SAASiF,gBAAgBC,cAAgBpE,EAAgBI,GAAkB,IAC/FU,KAAKC,MAAMd,OAAOf,SAASiF,gBAAgBE,aAAe,KAGhFC,c","file":"main.js","sourcesContent":["import { CustomNode, ListOfCustomNode } from \"../../node\";\r\n\r\nconst getNeighbors = (\r\n    nodeId: string, \r\n    listOfNodes: ListOfCustomNode,\r\n    grid: CustomNode[][]\r\n) => {\r\n    const coordinates: string[]= nodeId.split(\"-\");\r\n    const x: number= parseInt(coordinates[0]);\r\n    const y: number= parseInt(coordinates[1]);\r\n\r\n    const neighbor = [];\r\n    let potentialNeighbor: string;\r\n\r\n    // if there exist a row above current row and current col idx in that row\r\n    if (grid[x-1] && grid[x-1][y]){\r\n        potentialNeighbor = `${(x - 1).toString()}-${(y.toString())}`;  // make that coords potential neighbor\r\n        if(listOfNodes[potentialNeighbor].status !== \"wall\"){\r\n            neighbor.unshift(potentialNeighbor);    // Add potentialNeighbor at the beginning of neighbor array if node is not wall\r\n        }\r\n    }\r\n\r\n    // if there exist next column in current row\r\n    if (grid[x][y + 1]){\r\n        potentialNeighbor = `${x.toString()}-${(y + 1).toString()}`;    // make that coords potential neighbor\r\n        if(listOfNodes[potentialNeighbor].status !== \"wall\"){\r\n            neighbor.unshift(potentialNeighbor);\r\n        }\r\n    }\r\n\r\n    if (grid[x + 1] && grid[x + 1][y]){\r\n        potentialNeighbor = `${(x + 1).toString()}-${(y).toString()}`;    // make that coords potential neighbor\r\n        if(listOfNodes[potentialNeighbor].status !== \"wall\"){\r\n            neighbor.unshift(potentialNeighbor);\r\n        }\r\n    }\r\n    \r\n    if (grid[x][y - 1]){\r\n        potentialNeighbor = `${x.toString()}-${(y - 1).toString()}`;    // make that coords potential neighbor\r\n        if(listOfNodes[potentialNeighbor].status !== \"wall\"){\r\n            neighbor.unshift(potentialNeighbor);\r\n        }\r\n    }\r\n\r\n    return neighbor;\r\n}\r\n\r\nexport default getNeighbors;","import { CustomNode } from \"../node\";\r\nimport { NODE_ANIMATION_TIME } from \"./index\";\r\n\r\nconst nodeTraverse = async(nodesInOrder: CustomNode[]) => {\r\n    return new Promise((resolve) => {\r\n        for (let i: number= 0; i < nodesInOrder.length; i++){\r\n            setTimeout(() => {\r\n                const id: string= nodesInOrder[i].id;\r\n                const node: Element= document.getElementById(id)!;\r\n    \r\n                node.classList.contains(\"isStart\") || node.classList.contains(\"isTarget\") \r\n                ? node.classList.add(\"visited\")\r\n                : node.className = \"visited\";\r\n    \r\n                if(i === nodesInOrder.length - 1) resolve(true);\r\n            }, NODE_ANIMATION_TIME * i);\r\n\r\n        }\r\n    })\r\n}\r\n\r\nexport default nodeTraverse;","export const NODE_ANIMATION_TIME = 12;\r\n\r\nexport { default as nodeTraverse } from './node-traverse';\r\nexport { default as shortestDistance } from './node-shortest-distance';\r\n","interface CustomNode {\r\n  id: string,\r\n  row: number,\r\n  column: number,\r\n  status: string,\r\n  distance: number,\r\n  previousNode: CustomNode | null\r\n}\r\n\r\ninterface ListOfCustomNode{\r\n  [propNames: string]: CustomNode\r\n}\r\n\r\nclass Node {\r\n  id: string;\r\n  distance: number;\r\n  previousNode: CustomNode | null;\r\n\r\n  constructor(\r\n    public row: number,\r\n    public column: number,\r\n    public status: string\r\n  ){\r\n    this.id = `${row}-${column}`;\r\n    this.distance = 0;\r\n    this.previousNode = null;\r\n  }\r\n}\r\n\r\nexport {\r\n  Node,\r\n  CustomNode,\r\n  ListOfCustomNode\r\n}","interface CustomData {\r\n    [prop: string]: string\r\n}\r\n\r\nexport const DATA: CustomData = {\r\n    \"DFS\": \"Depth-first Search is <strong>&nbsp; unweighted &nbsp;</strong> and <strong>&nbsp; does not guarantee &nbsp;</strong> the shortest path!\",\r\n    \"BFS\": \"Breath-first Search is <strong>&nbsp; unweighted &nbsp;</strong> and <strong>&nbsp; does not guarantee &nbsp;</strong> the shortest path!\"\r\n}\r\n  ","import Board from './components/board';\r\nimport \"./style.scss\";\r\n\r\n// Get Height of other elements in body\r\nconst HEADER_HEIGHT: number = Number(document.querySelector(\".header\")?.clientHeight);\r\nconst CONTENT_HEIGHT: number = Number(document.querySelector(\".description\")?.clientHeight) + Number(document.querySelector(\".intro\")?.clientHeight);\r\n\r\n// Obtain height and width of board\r\nconst BOARD_HEIGHT: number = Math.floor((Number(document.documentElement.scrollHeight) - HEADER_HEIGHT - CONTENT_HEIGHT) / 28);\r\nconst BOARD_WIDTH: number = Math.floor(Number(document.documentElement.clientWidth) / 25);\r\n\r\nconst BOARD = new Board(BOARD_HEIGHT, BOARD_WIDTH);\r\nBOARD.initialize();","import depthFirstSearch from \"./algorithms/unweighted/depth-first-search\";\r\nimport { shortestDistance } from \"./animations/index\";\r\nimport nodeTraverse from \"./animations/node-traverse\";\r\nimport { CustomNode, Node, ListOfCustomNode } from \"./node\";\r\nimport { DATA } from \"./data\";\r\n\r\nclass Board {\r\n    isStart: string;                            // Starting Point\r\n    isTarget: string;                           // Target Point\r\n    allNodes: ListOfCustomNode;                 // Contains instance of all the nodes present in board with \"node_id\" as \"key\" and \"Node itself\" as \"value\" \r\n    grid: CustomNode[][];                       // Storing all table rows \"Array<Array<CustomNode>>\"\r\n    nodesInOrder: CustomNode[];                 // Stores node in an order in which it is traversed\r\n    shortestPathNodesInOrder: CustomNode[];     // Contains shortest path nodes\r\n    \r\n    visualizeComponent: HTMLElement;                // Getting Visualize Button\r\n    descriptionComponent: HTMLElement;              // Getting Description Component\r\n\r\n    initialStart: {row: number, col: number}    // Initializing start node\r\n    initialTarget: {row: number, col: number}   // Initializing target node\r\n\r\n    pressedNodeStatus: string                   // On mouse event - stores pressed node status\r\n    mouseDown: boolean                          // To check whether the mouse is pressed or not\r\n    previouslySwitchedNode: CustomNode | null   // Tracking previously switched node\r\n    previouslyPressedNodeStatus: string         // Tracking previously pressed node status\r\n\r\n    constructor(\r\n        public height: number,\r\n        public width: number\r\n    ) {\r\n        this.isStart = \"\";\r\n        this.isTarget = \"\";\r\n        this.allNodes = {};\r\n        this.grid = [];\r\n        this.nodesInOrder = [];\r\n        this.shortestPathNodesInOrder = [];\r\n\r\n        this.visualizeComponent = <HTMLElement>document.querySelector(\"#visualize\")!;\r\n        this.descriptionComponent = <HTMLElement>document.querySelector(\".description\")!;\r\n\r\n        this.initialStart = {\r\n            row: Math.floor(this.height / 2),\r\n            col: Math.floor(this.width / 4)\r\n        }\r\n        this.initialTarget = {\r\n            row: Math.floor(this.height / 2),\r\n            col: Math.floor(3 * this.width / 4)\r\n        }\r\n\r\n        this.pressedNodeStatus = \"\";\r\n        this.mouseDown = false;\r\n        this.previouslySwitchedNode = null;\r\n        this.previouslyPressedNodeStatus = \"\";\r\n    }\r\n\r\n    initialize() {\r\n        this.createGrid();\r\n        this.toggleSwitch();\r\n        this.eventListeners();\r\n    }\r\n\r\n    createGrid() {\r\n        const board: Element = document.querySelector(\"#board\")!;    // Select Board Elements (! -> mandatory)\r\n        const tbody: Element = document.createElement(\"tbody\");\r\n\r\n        for (let row: number = 0; row < this.height; row++){\r\n            const currentArrayRow: Node[] = [];\r\n\r\n            // Create table row element\r\n            const currentRow: HTMLTableRowElement = document.createElement(\"tr\");\r\n            currentRow.id = `row ${row}`;\r\n\r\n            for (let col: number = 0; col < this.width; col++){\r\n                const nodeId: string= `${row}-${col}`;\r\n\r\n                let nodeStatus: string, \r\n                    newNode: CustomNode;\r\n\r\n                // Calculating start and target position\r\n                if (row === this.initialStart.row && col === this.initialStart.col){\r\n                    nodeStatus = \"isStart\";     // marking current node as start node\r\n                    this.isStart = nodeId;      // storing current node in isStart\r\n                }else if (row === this.initialTarget.row && col === this.initialTarget.col){\r\n                    nodeStatus = \"isTarget\";    // marking current node as target node\r\n                    this.isTarget = nodeId;     // storing current node in isTarget\r\n                }else{\r\n                    nodeStatus = \"unvisited\";   // marking rest as unvisited\r\n                }\r\n\r\n                newNode = new Node(row, col, nodeStatus);   // Creating instance of node\r\n                currentArrayRow.push(newNode);              // Pushing new instance in row array\r\n                this.allNodes[nodeId] = newNode;       // Storing it inside allNodes\r\n\r\n                // Creating board cell\r\n                const tableCell: HTMLTableDataCellElement= document.createElement(\"td\");\r\n                tableCell.id = nodeId;\r\n                tableCell.classList.add(nodeStatus);\r\n\r\n                currentRow.append(tableCell);\r\n            }\r\n            this.grid.push(currentArrayRow);\r\n            tbody.append(currentRow);\r\n            board.append(tbody);\r\n        }\r\n\r\n        // Visualize\r\n        this.visualizeComponent.addEventListener('click', () => {\r\n            const dataVisualize: string = this.visualizeComponent.getAttribute(\"data-visualize\")!;\r\n            if(dataVisualize !== \"\"){\r\n                this.drawShortestPath(dataVisualize);\r\n            }\r\n        })\r\n    }\r\n\r\n    toggleSwitch() {\r\n        const algorithmsList = document.querySelector(\"#algorithms-list\")!;\r\n\r\n        algorithmsList.addEventListener('mousedown', (e) => {\r\n            const el = e.target as HTMLElement;\r\n            const dataId = el.dataset.id;\r\n\r\n            if (dataId){\r\n                this.visualizeComponent.textContent = `Visualize ${dataId}`;\r\n                this.visualizeComponent.setAttribute(\"data-visualize\", `${dataId}`);\r\n                this.descriptionComponent.innerHTML = DATA[dataId];\r\n            }\r\n        })\r\n    }\r\n\r\n    async drawShortestPath(dataVisualize: string) {\r\n        if(dataVisualize === \"DFS\"){\r\n            depthFirstSearch(this.allNodes, this.isStart, this.isTarget, this.grid, this.nodesInOrder);\r\n            const traverse = await nodeTraverse(this.nodesInOrder);\r\n            console.log(this.nodesInOrder);\r\n            traverse && shortestDistance(this.shortestPathNodesInOrder, this.isStart, this.isTarget, this.allNodes);\r\n        }\r\n    }\r\n\r\n    eventListeners() {\r\n        Object.entries(this.allNodes).map(node => {\r\n            const [key, value] = node;  // \"key\" represents ID & \"value\" represents NODE\r\n            const currentElement: HTMLElement= document.getElementById(key)!;    // Not using queryselector as it does not support id starting with digit\r\n        \r\n            // On mouse press event\r\n            currentElement.addEventListener(\"mousedown\", (e) => {\r\n                const target: HTMLElement= (<HTMLElement>e.target);\r\n\r\n                this.mouseDown = true;\r\n\r\n                if(value.status === \"isStart\" || value.status === \"isTarget\") {\r\n                    this.pressedNodeStatus = value.status;\r\n                }else {\r\n                    this.changeNormalNode(target, value);\r\n                    console.log(node);\r\n                }\r\n            });\r\n\r\n            // On mouse release event\r\n            currentElement.addEventListener(\"mouseup\", () => {\r\n                this.mouseDown = false;\r\n\r\n                if(this.pressedNodeStatus === \"isStart\") {\r\n                    this.isStart = key;\r\n                }else if(this.pressedNodeStatus === \"isTarget\") {\r\n                    this.isTarget = key;\r\n                }\r\n\r\n                this.pressedNodeStatus = \"normal\";\r\n            });\r\n\r\n            // On mouse hovering event\r\n            currentElement.addEventListener('mouseenter', (e) => {\r\n                if(this.mouseDown){\r\n                    const target: HTMLElement= (<HTMLElement>e.target);\r\n                    if(this.mouseDown && this.pressedNodeStatus !== \"normal\"){\r\n                        this.changeSpecialNode(target, value);\r\n                        if(this.pressedNodeStatus === \"isStart\") {\r\n                            this.isStart = key;\r\n                        }else if(this.pressedNodeStatus === \"isTarget\") {\r\n                            this.isTarget = key;\r\n                        }\r\n                    }else{\r\n                        this.changeNormalNode(target, value);\r\n                    }\r\n                }\r\n            });\r\n\r\n            // On mouse leave event\r\n            currentElement.addEventListener('mouseleave', (e) => {\r\n                const target: HTMLElement= (<HTMLElement>e.target);\r\n\r\n                if(this.mouseDown && this.pressedNodeStatus !== \"normal\") {\r\n                    this.changeSpecialNode(target, value);\r\n                }\r\n            })\r\n        })\r\n    }\r\n\r\n    // Changing normal node role from unvisited to wall or v.v.\r\n    changeNormalNode(target: HTMLElement, node: CustomNode) {\r\n        const relevantStatus = [\"isStart\", \"isTarget\"];\r\n\r\n        if(!relevantStatus.includes(node.status)) {\r\n            target.className = node.status === \"unvisited\" ? \"wall\" : \"unvisited\";\r\n            node.status = target.className === \"unvisited\" ? \"unvisited\" : \"wall\";\r\n        }\r\n    }\r\n\r\n    // Changing special (i.e., start, target) node position\r\n    changeSpecialNode(target: HTMLElement, node: CustomNode){\r\n        let previousElement: HTMLElement | null = null;\r\n\r\n        // If there exist previous switched node get that element\r\n        this.previouslySwitchedNode !== null\r\n        && (previousElement = document.getElementById(this.previouslySwitchedNode.id));\r\n\r\n        if(node.status !== \"isStart\" && node.status !== \"isTarget\") {\r\n            if(this.previouslySwitchedNode) {\r\n                this.previouslySwitchedNode.status = this.previouslyPressedNodeStatus;\r\n                previousElement!.className = this.previouslyPressedNodeStatus;\r\n\r\n                this.previouslySwitchedNode = null;\r\n\r\n                this.previouslyPressedNodeStatus = node.status;\r\n                target.className = this.pressedNodeStatus;\r\n                node.status = this.pressedNodeStatus;\r\n            }\r\n        }else if(node.status !== this.pressedNodeStatus) {\r\n            if(this.previouslySwitchedNode) {\r\n                this.previouslySwitchedNode.status = this.pressedNodeStatus;\r\n                previousElement!.className = this.pressedNodeStatus;\r\n            }\r\n        }else if(node.status === this.pressedNodeStatus) {\r\n            this.previouslySwitchedNode = node;\r\n            target.className = this.previouslyPressedNodeStatus;\r\n            node.status = this.previouslyPressedNodeStatus;\r\n        }\r\n    }\r\n}\r\n\r\nexport default Board","import { CustomNode, ListOfCustomNode } from \"../../node\";\r\nimport getNeighbors from \"./get-neighbors\";\r\n\r\nconst depthFirstSearch = (\r\n    listOfNodes: ListOfCustomNode, \r\n    startNode: string, \r\n    targetNode: string, \r\n    grid: CustomNode[][],\r\n    nodesInOrder: CustomNode[]\r\n): boolean => {\r\n\r\n    if (startNode === \"\" || targetNode === \"\" || startNode === targetNode) return false;\r\n\r\n    let stack: CustomNode[] = [listOfNodes[startNode]]\r\n    const exploredNode: {\r\n        [propNames: string] : boolean\r\n    } = {startNode: true}\r\n\r\n    while (stack.length){\r\n        let currentNode: CustomNode = stack.pop()!;\r\n        exploredNode[currentNode.id] = true;\r\n        nodesInOrder.push(currentNode);\r\n        currentNode.status = \"visited\";\r\n\r\n        if (currentNode.id === targetNode) return true;\r\n\r\n        let currentNeighbors = getNeighbors(currentNode.id, listOfNodes, grid);\r\n        currentNeighbors.forEach(neighbor => {\r\n            if (!exploredNode[neighbor]){\r\n                listOfNodes[neighbor].previousNode = currentNode;\r\n                stack.push(listOfNodes[neighbor]);\r\n            }\r\n        })\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport default depthFirstSearch;","import { CustomNode, ListOfCustomNode } from \"../node\";\r\nimport { NODE_ANIMATION_TIME } from \"./index\";\r\n\r\nconst shortestDistance = (nodesInShortestOrder: CustomNode[], isStart: string, isTarget: string, allNodes: ListOfCustomNode) => {\r\n    \r\n    let currentNode: CustomNode | null= allNodes[isTarget];\r\n\r\n    /* \r\n        Looping through while current node is not equal to start node \r\n        to get the shortest route that it has to traverse to reach its destination\r\n    */\r\n    while(currentNode !== null){\r\n        nodesInShortestOrder.unshift(currentNode);\r\n        currentNode = allNodes[currentNode.id].previousNode;\r\n    }\r\n    \r\n    // Animating nodesInShortestOrder\r\n    for (let i: number= 0; i < nodesInShortestOrder.length; i++){\r\n        setTimeout(() => {\r\n            const id: string= nodesInShortestOrder[i].id;\r\n            const node: Element= document.getElementById(id)!;\r\n\r\n            node.classList.contains(\"isStart\") || node.classList.contains(\"isTarget\") \r\n            ? node.classList.add(\"shortest-path\")\r\n            : node.className = \"shortest-path\";\r\n\r\n        }, NODE_ANIMATION_TIME * (2 * i));\r\n    }\r\n}\r\n\r\nexport default shortestDistance;"],"sourceRoot":""}